#include "MultiGraph.h"
#include "Exceptions.h"
#include "IntPair.h"
#include <iostream>
#include <iomanip>
#include <fstream>

//=======================//
// Implemented Functions //
//=======================//
MultiGraph::MultiGraph()
{}

MultiGraph::MultiGraph(const std::string& filePath)
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    // Tokens
    std::string tokens[5];
    std::ifstream mapFile(filePath.c_str());

    if(!mapFile.is_open())
    {
        std::cout << "Unable to open " << filePath << std::endl;
        return;
    }

    // Read line by line
    std::string line;
    while (std::getline(mapFile, line))
    {
        // Empty Line Skip
        if(line.empty()) continue;
        // Comment Skip
        if(line[0] == '#') continue;

        // Tokenize the line
        int i = 0;
        std::istringstream stream(line);
        while(stream >> tokens[i]) i++;

        // Single token (Meaning it is a vertex)
        if(i == 1)
        {
            InsertVertex(tokens[0]);
        }
        // Exactly 5 tokens (Meaning it is an edge)
        else if(i == 5)
        {
            // Rename vars for readablity
            const std::string& vertexFromName = tokens[0];
            const std::string& vertexToName = tokens[1];
            const std::string& edgeName = tokens[2];
            float weight0 = static_cast<float>(std::atof(tokens[3].c_str()));
            float weight1 = static_cast<float>(std::atof(tokens[4].c_str()));
            AddEdge(edgeName, vertexFromName, vertexToName,
                    weight0, weight1);
        }
        else std::cerr << "Token Size Mismatch" << std::endl;
    }
}

void MultiGraph::PrintPath(const std::vector<int>& orderedVertexEdgeIndexList,
                           float heuristicWeight,
                           bool sameLine) const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this file !       //
    // ============================= //

    // Name is too long
    const std::vector<int>& ove = orderedVertexEdgeIndexList;
    // Invalid list
    // At least three items should be available
    if(ove.size() < 3) return;

    // Check vertex and an edge
    for(size_t i = 0; i < orderedVertexEdgeIndexList.size(); i += 2)
    {
        int vertexId = ove[i];
        if(vertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                      << " not found!" << std::endl;
            return;
        }


        const GraphVertex& vertex = vertexList[vertexId];
        std::cout << vertex.name;
        if(!sameLine) std::cout << "\n";
        // Only find and print the weight if next is available
        if(i == ove.size() - 1) break;
        int nextVertexId = ove[i + 2];
        if(nextVertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                    << " not found!" << std::endl;
            return;
        }

        // Find the edge between these two vertices
        int localEdgeId = ove[i + 1];
        if(localEdgeId >= static_cast<int>(vertex.edges.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "EdgeId " << localEdgeId
                      << " not found in " << vertexId << "!" << std::endl;
            return;
        }

        const GraphEdge& edge = vertex.edges[localEdgeId];

        // Combine with heuristic (linear interpolation)
        float weight = Lerp(edge.weight[0], edge.weight[1],
                            heuristicWeight);

        std::cout << "-" << std::setfill('-')
                  << std::setw(4)
                  << weight << "->";
    }
    // Print endline on the last vertex if same line is set
    if(sameLine) std::cout << "\n";
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

void MultiGraph::PrintEntireGraph() const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    for(size_t i = 0; i < vertexList.size(); i++)
    {
        const GraphVertex& v = vertexList[i];
        std::cout << v.name << "\n";
        for(size_t j = 0; j < v.edges.size(); j++)
        {
            const GraphEdge& edge = v.edges[j];

            // List the all vertex names and weight
            std::cout << "    -"
                      << std::setfill('-')
                      << std::setw(4) << edge.weight[0]
                      << "-"
                      << std::setw(4) << edge.weight[1]
                      << "-> ";
            std::cout << vertexList[edge.endVertexIndex].name;
            std::cout << " (" << edge.name << ")" << "\n";
        }
    }
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

//=======================//
//          TODO         //
//=======================//
int MultiGraph::getVertexCount() const {
        return vertexList.size();
    }

int MultiGraph::FindMaxNonVisitedNeighbors(const std::vector<bool>& visited) const {
    int maxNeighbors = -1;
    int selectedAirport = -1;

    // Iterate over all airports
    for (int i = 0; i < vertexList.size(); ++i) {
        // Check only visited airports
        if (visited[i]) {
            int nonVisitedNeighbors = CountNonVisitedNeighbors(i, visited);

            // Update if the current airport has more non-visited neighbors
            if (nonVisitedNeighbors > maxNeighbors) {
                maxNeighbors = nonVisitedNeighbors;
                selectedAirport = i;
            }
        }
    }

    return selectedAirport;
}

int MultiGraph::CountNonVisitedNeighbors(int airportIndex, const std::vector<bool>& visited) const {
    int count = 0;
    const GraphVertex& currentAirport = vertexList[airportIndex];

    // Iterate over the edges of the current airport
    for (const GraphEdge& edge : currentAirport.edges) {
        // Check if the neighbor airport is not visited
        if (!visited[edge.endVertexIndex]) {
            ++count;
        }
    }

    return count;
}

GraphVertex MultiGraph::getVertex(int airportindex) const {
    return vertexList[airportindex];

}


void MultiGraph::visit_nodes(int airportIndex, std::vector<std::string> airlineNames, std::vector<bool>& visited) const{
    visited[airportIndex] = true;
    for (const std::string& airlineName : airlineNames){
        for(int i = 0; i < vertexList[airportIndex].edges.size(); i++){
            if(airlineName == vertexList[airportIndex].edges[i].name){
                if(!visited[vertexList[airportIndex].edges[i].endVertexIndex]){
                    
                    int newindex = vertexList[airportIndex].edges[i].endVertexIndex;
                    visited[newindex] = true;
                    visit_nodes(newindex, airlineNames, visited);
                }
            } 
    }
        
    }

}

bool MultiGraph::VisitAirportsWithAirlineCheck(int airportIndex, std::string& airlineName) const {
    // Check if there is at least one other airport reached using the specified airline
    const GraphVertex& currentAirport = vertexList[airportIndex];
    for (const GraphEdge& edge : currentAirport.edges) {
        if (edge.name == airlineName) {
            return true;
        }
    }
    return false;
}


int MultiGraph::indices(const std::string& name) const{
    int index = -1;
    
    
    for(int i = 0; i < vertexList.size(); i++){
        if(vertexList[i].name == name) index = i;
    }

    return index;
    

}
GraphEdge MultiGraph::edgeweights(const std::string& edgeName,const std::string& vertexFromName,const std::string& vertexToName) const{
    int from_index = -1;
    int to_index = -1;
    int edge_index = -1;
    
    for(int i = 0; i < vertexList.size(); i++){
        if(vertexList[i].name == vertexFromName) from_index = i;
        if(vertexList[i].name == vertexToName) to_index = i;
    }
    
    
    for(int i = 0; i < vertexList[from_index].edges.size(); i++){
        if(vertexList[from_index].edges[i].name == edgeName && vertexList[from_index].edges[i].endVertexIndex == to_index) edge_index = i;
    }
    GraphEdge returnedge;
    returnedge = vertexList[from_index].edges[edge_index];
    return returnedge;
    
   
}

bool MultiGraph::edgeexists(const std::string& edgeName,const std::string& vertexFromName,const std::string& vertexToName){
    int from_index = -1;
    int to_index = -1;
    int edge_index = -1;

    for(int i = 0; i < vertexList.size(); i++){
        if(vertexList[i].name == vertexFromName) from_index = i;
        if(vertexList[i].name == vertexToName) to_index = i;
    }
    if(from_index == -1) return false;
    if(to_index == -1) return false;
    
    for(int i = 0; i < vertexList[from_index].edges.size(); i++){
        if(vertexList[from_index].edges[i].name == edgeName) edge_index = i;
    }
    if(edge_index == -1) return false;
    return true; 
}
bool MultiGraph::airportexists(const std::string& vertexFromName,const std::string& edgeName) const{
    int from_index = -1;
    int edge_index = -1;

    for(int i = 0; i < vertexList.size(); i++){
        if(vertexList[i].name == vertexFromName) from_index = i;
        
    }
    if(from_index == -1) return false;
    
    for(int i = 0; i < vertexList[from_index].edges.size(); i++){
        if(vertexList[from_index].edges[i].name == edgeName) edge_index = i;
    }
    if(edge_index == -1) return false;
    
    return true; 
}
float MultiGraph::Lerp(float w0, float w1, float alpha)
{
    /* TODO */
    return  w1 * alpha + w0 * (1 - alpha);
}

void MultiGraph::InsertVertex(const std::string& vertexName)
{
    /* TODO */
    for(int i = 0; i < vertexList.size(); ++i){
        if(vertexList[i].name == vertexName) throw DuplicateVertexException(vertexName);
    }
    GraphVertex new_vertex;
    new_vertex.name = vertexName;
    vertexList.push_back(new_vertex);
}

void MultiGraph::RemoveVertex(const std::string& vertexName)
{
    /* TODO */
    int index = -1;
    for(int i=0; i < vertexList.size(); i++){
        if(vertexList[i].name == vertexName){
            index = i;
            break;
        }
    }
    if(index == -1) throw VertexNotFoundException(vertexName);

    for(int i = 0; i < vertexList.size(); i++){
        for(int j = 0; j < vertexList[i].edges.size(); j++){
            if(vertexList[i].edges[j].endVertexIndex == index){
                vertexList[i].edges.erase(vertexList[i].edges.begin() + j);
                j--;
            }
        }
    }
    vertexList.erase(vertexList.begin() + index);
}

void MultiGraph::AddEdge(const std::string& edgeName,
                         const std::string& vertexFromName,
                         const std::string& vertexToName,
                         float weight0, float weight1)
{
    /* TODO */
    int from_index = -1;
    int to_index = -1;

    for(int i = 0; i < vertexList.size(); i++){
        if(vertexList[i].name == vertexFromName) from_index = i;
        if(vertexList[i].name == vertexToName) to_index = i;
    }
    if(from_index == -1) throw VertexNotFoundException(vertexFromName);
    if(to_index == -1) throw VertexNotFoundException(vertexToName);
    
    for(int i = 0; i < vertexList[from_index].edges.size(); i++){
        if(vertexList[from_index].edges[i].name == edgeName && vertexList[from_index].edges[i].endVertexIndex == to_index ) throw SameNamedEdgeException(edgeName, vertexFromName, vertexToName);
    }
    
    GraphEdge new_edge;
    new_edge.name = edgeName;
    new_edge.weight[0] = weight0;
    new_edge.weight[1] = weight1;
    new_edge.endVertexIndex = to_index;
    vertexList[from_index].edges.push_back(new_edge);
}

void MultiGraph::RemoveEdge(const std::string& edgeName,
                            const std::string& vertexFromName,
                            const std::string& vertexToName)
{
    /* TODO */
    int from_index = -1;
    int to_index = -1;
    int edge_index = -1;

    for(int i = 0; i < vertexList.size(); i++){
        if(vertexList[i].name == vertexFromName) from_index = i;
        if(vertexList[i].name == vertexToName) to_index = i;
    }
    if(from_index == -1) throw VertexNotFoundException(vertexFromName);
    if(to_index == -1) throw VertexNotFoundException(vertexToName);
    
    for(int i = 0; i < vertexList[from_index].edges.size(); i++){
        if(vertexList[from_index].edges[i].name == edgeName && vertexList[from_index].edges[i].endVertexIndex == to_index) edge_index = i;
    }
    if(edge_index == -1) throw EdgeNotFoundException(vertexFromName, edgeName);
    vertexList[from_index].edges.erase(vertexList[from_index].edges.begin() + edge_index);
}

bool MultiGraph::HeuristicShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                       const std::string& vertexNameFrom,
                                       const std::string& vertexNameTo,
                                       float heuristicWeight) const
{
    /* TODO */
    int from_index = -1;
    int to_index = -1;

    for (int i = 0; i < vertexList.size(); i++) {
        if (vertexList[i].name == vertexNameFrom) from_index = i;
        if (vertexList[i].name == vertexNameTo) to_index = i;
    }

    if (from_index == -1) throw VertexNotFoundException(vertexNameFrom);
    if (to_index == -1) throw VertexNotFoundException(vertexNameTo);

    MinPairHeap<float, int> pq;
    std::vector<float> distance(vertexList.size(), 99999999);
    std::vector<int> previous(vertexList.size(), -1);

    distance[from_index] = 0.0;
    for (int i = 0; i < vertexList.size(); i++) {
        distance[i] = (i == from_index) ? 0.0 : 99999999;
        pq.push({distance[i], i});
    }

    while(!pq.empty()){
        Pair<float, int> top_pair = pq.top();
        pq.pop();
        int current_index = top_pair.value;
        if(current_index == to_index){
            int vertex_index = to_index;
            int edgeindex;
            int check = 0;
            while(vertex_index != from_index){
                if(vertex_index == to_index && check == 0) {
                    orderedVertexEdgeIndexList.push_back(vertex_index);
                    check--;
                    continue;
                }
                int prev_index = previous[vertex_index];
                float current_cost = distance[vertex_index]- distance[prev_index];
                for(int i = 0; i < vertexList[prev_index].edges.size();i++){ 
                    
                    if(vertexList[prev_index].edges[i].endVertexIndex == vertex_index && abs(Lerp(vertexList[prev_index].edges[i].weight[0], vertexList[prev_index].edges[i].weight[1], heuristicWeight) - current_cost)< 0.0001) edgeindex = i;
                    }
                
                orderedVertexEdgeIndexList.push_back(edgeindex);
                orderedVertexEdgeIndexList.push_back(prev_index);
                
                vertex_index = prev_index;
                }
                //ters çevirecez
                size_t start = 0;
                size_t end = orderedVertexEdgeIndexList.size() - 1;

                while (start < end) {
                    
                    int temp = orderedVertexEdgeIndexList[start];
                    orderedVertexEdgeIndexList[start] = orderedVertexEdgeIndexList[end];
                    orderedVertexEdgeIndexList[end] = temp;

                    
                    start++;
                    end--;
                }
                return true;
        }
        for (size_t i = 0; i < vertexList[current_index].edges.size(); i++) {
            const GraphEdge& edge = vertexList[current_index].edges[i];
            int neighbor_index = edge.endVertexIndex;

            float edge_weight = Lerp(edge.weight[0], edge.weight[1], heuristicWeight);

            
            float new_distance = distance[current_index] + edge_weight;

            // Update distance and priority queue if it's shorter
            if (new_distance < distance[neighbor_index]) {
                distance[neighbor_index] = new_distance;
                previous[neighbor_index] = current_index;
                pq.push({new_distance, neighbor_index});
            }
        }

    }
    return false;
}




bool MultiGraph::FilteredShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                      const std::string& vertexNameFrom,
                                      const std::string& vertexNameTo,
                                      float heuristicWeight,
                                      const std::vector<std::string>& edgeNames) const
{
    int from_index = -1;
    int to_index = -1;

    for (int i = 0; i < vertexList.size(); i++) {
        if (vertexList[i].name == vertexNameFrom) from_index = i;
        if (vertexList[i].name == vertexNameTo) to_index = i;
    }

    if (from_index == -1) throw VertexNotFoundException(vertexNameFrom);
    if (to_index == -1) throw VertexNotFoundException(vertexNameTo);

    MinPairHeap<float, int> pq;
    std::vector<float> distance(vertexList.size(), 99999999);
    std::vector<int> previous(vertexList.size(), -1);

    distance[from_index] = 0.0;
    for (int i = 0; i < vertexList.size(); i++) {
        distance[i] = (i == from_index) ? 0.0 : 99999999;
        pq.push({distance[i], i});
    }

    while(!pq.empty()){
        Pair<float, int> top_pair = pq.top();
        pq.pop();
        int current_index = top_pair.value;
        if(current_index == to_index){
            int vertex_index = to_index;
            int edgeindex;
            int check = 0;
            while(vertex_index != from_index){
                if(vertex_index == to_index && check == 0) {
                    orderedVertexEdgeIndexList.push_back(vertex_index);
                    check--;
                    continue;
                }
                int prev_index = previous[vertex_index];
                if(prev_index < 0) return false;
                float current_cost = distance[vertex_index]- distance[prev_index];
                for(int i = 0; i < vertexList[prev_index].edges.size();i++){ 
                    
                    if(vertexList[prev_index].edges[i].endVertexIndex == vertex_index && abs(Lerp(vertexList[prev_index].edges[i].weight[0], vertexList[prev_index].edges[i].weight[1], heuristicWeight) - current_cost)< 0.0001) edgeindex = i;
                    }
                orderedVertexEdgeIndexList.push_back(edgeindex);
                orderedVertexEdgeIndexList.push_back(prev_index);
                
                vertex_index = prev_index;
                }
                //ters çevirecez
                size_t start = 0;
                size_t end = orderedVertexEdgeIndexList.size() - 1;

                while (start < end) {
                    
                    int temp = orderedVertexEdgeIndexList[start];
                    orderedVertexEdgeIndexList[start] = orderedVertexEdgeIndexList[end];
                    orderedVertexEdgeIndexList[end] = temp;

                    
                    start++;
                    end--;
                }
                return true;
        }
        for (size_t i = 0; i < vertexList[current_index].edges.size(); i++) {
            int check = 0;
            for(int j = 0; j < edgeNames.size(); j++){
                if(vertexList[current_index].edges[i].name == edgeNames[j]){
                    check = 1;
                    break;
                }
                }
            if(check == 0){    
                const GraphEdge& edge = vertexList[current_index].edges[i];
                int neighbor_index = edge.endVertexIndex;
    
                float edge_weight = Lerp(edge.weight[0], edge.weight[1], heuristicWeight);
    
                
                float new_distance = distance[current_index] + edge_weight;
    
                // Update distance and priority queue if it's shorter
                if (new_distance < distance[neighbor_index]) {
                    distance[neighbor_index] = new_distance;
                    previous[neighbor_index] = current_index;
                    pq.push({new_distance, neighbor_index});
                }
        }
        }

    }
    return false;
}

int MultiGraph::BiDirectionalEdgeCount() const
{
    int count = 0;

    for (int i = 0; i < vertexList.size(); i++) {
        for (int j = 0; j < vertexList[i].edges.size(); j++) {
            const GraphEdge& thisedge = vertexList[i].edges[j];
            int to_index = thisedge.endVertexIndex;

            const GraphVertex& targetvertex = vertexList[to_index];

            if (to_index > i) {
                for (int k = 0; k < targetvertex.edges.size(); k++) {
                    if (targetvertex.edges[k].name == thisedge.name &&
                        targetvertex.edges[k].endVertexIndex == i) {
                        count++;
                        break;
                    }
                }
            }
        }
    }

    return count;
}


int MultiGraph::MaxDepthViaEdgeName(const std::string& vertexName, const std::string& edgeName) const {
    
    int from_index = -1;
    for (int i = 0; i < vertexList.size(); ++i) {
        if (vertexList[i].name == vertexName) {
            from_index = i;
            break;
        }
    }

    if (from_index == -1) throw VertexNotFoundException(vertexName);
    
    std::vector<bool> visited(vertexList.size(), false);
    MinPairHeap<int, int> dfs_queue;
    int depth = 0;

    dfs_queue.push({depth, from_index});  

    while (!dfs_queue.empty()) {
        Pair<int, int> top_pair = dfs_queue.top();
        int currentDepth = top_pair.key;
        int currentIndex = top_pair.value;

        dfs_queue.pop();
        if(visited[currentIndex]) continue;
        visited[currentIndex] = true;

        
        depth = depth > currentDepth ? depth : currentDepth;

        
        for (size_t i = 0; i < vertexList[currentIndex].edges.size(); i++) {
            const GraphEdge& edge = vertexList[currentIndex].edges[i];
            if (edge.name == edgeName) {
                int nextIndex = edge.endVertexIndex;

                
                dfs_queue.push({currentDepth + 1, nextIndex});
            }
        }
    }

    return depth;
}